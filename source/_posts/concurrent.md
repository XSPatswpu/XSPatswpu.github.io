---
title: 如果有人问 volitale synchronized 原理，我该怎么回答？
date: 2020-09-26 17:16:28
categories: 并发编程
---

## 序
volitale synchronized 在并发编程中经常用到，而并发编程中的核心三大问题是：

* 原子性
* 可见性
* 有序性

本文将围绕三个问题，从硬件原理开始聊。

注：本文只是一篇初稿，错误在所难免，而且涉及很多的硬件细节更多的是我的猜想与假设。
<!-- more -->
## volatile、synchronized 能解决什么问题
volitale 能保证可见性与有序性，在特别情况下能保证原子性（后文会讲到）

synchronized 同时保证原子性、可见性、有序性
## 并发问题如何产生
### 原子性问题
JMM规定所有的赋值写操作都是原子的。

**特例**：在 32 位 JVM 中对（64位）long、double类型的赋值写操作不是原子的！32 位的 JVM 中对 long 类型变量的赋值操作，是分为低 32 位和高 32 位两步写完成的，多线程情况下存在并发问题，用 volatile 可以保证原子性。

**注意**：`i++`不是简单的赋值写操作
### 重排序问题如何产生
java 文件编译成 class 文件的过程中静态编译器（javac）会发生指令重排序，class 文件编译成机器语言的过程中，动态编译器（JIT）会发生指令重排序。处理器在执行指令的过程中，也有可能调整执行顺序。但是指令重排序并不能胡乱发生，JMM中规定了 Happens-Before 原则，专门用来限制指令重排序。

**JIT编译器对创建对象的指令重排以及double check单例实践**
未完待续
### 底层硬件可能产生的可见性问题
CPU 中存在寄存器、高速缓存、写缓冲区，可见性发生的场景：如果处理器 1 把数据写到寄存器（或高速缓存、写缓冲区）中，而处理器 2 无法看到最新的数据。

### MESI 协议可能产生的问题
#### MESI 协议简介
MESI协议是 CPU 缓存一致性协议.

要解决缓存一致性问题，首先要解决的是多个CPU核心之间的数据传播问题。最常见的一种解决方案呢，叫作总线嗅探（Bus Snooping）。这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的CPU核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。

基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议。不过其中最常用的，就是MESI协议。和很多现代的CPU技术一样，MESI协议也是在Pentium时代，被引入到Intel CPU中的。

MESI协议，是一种叫作**写失效（Write Invalidate）的协议**。在写失效协议里，只有一个CPU核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个CPU核心写入Cache之后，它会去广播一个“失效”请求告诉所有其他的CPU核心。其他的CPU核心，只是去判断自己是否也有一个“失效”版本的Cache Block，然后把这个也标记成失效的就好了。

相对于写失效协议，还有一种叫作写广播（Write Broadcast）的协议。在这个协议里，一个写入请求广播到所有的CPU核心，同时更新各个核心里的Cache。

写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的CPU核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他CPU核心。
#### MESI 协议产生的问题

修改变量的时候，要发送一些Invalidate给远程的CPU，等到远程CPU返回一个ACK，才能进行下一步。这一过程中如果远程的CPU比较繁忙，甚至会带来更大的延迟。并且如果有内存访问，会带来几百个周期的延迟。

所以CPU实现加入了优化，在写侧加入写缓冲区（store buffer）进行写缓存，写完立即返回；在变量状态需要变更侧加入无效队列（Invalidate Queue）来优化更新。

由于store buffer和Invalidate Queue的存在导致了变量状态的变更不及时，所以会引发可见性与有序性等问题。

**可见性问题**

**有序性问题**
## Java 内存模型如何解决可见性与有序性问题

### Java 内存模型
主要介绍四种内存屏障

以及最重要的一种内存屏障

### 内存屏障如何解决可见性与有序性问题
由于不同架构的CPU支持的内存屏障不同，x86 架构的 cpu 只支持 StoreLoad 屏障。下面介绍 StoreLoad 屏障是如何解决 MESI协议 引发的有序性和可见性问题。

```
store操作
StoreLoad屏障
load操作
```

可见性

StoreLoad 屏障保证，store 操作在写入写缓冲区之后，给总线发送 cache Invalidate 的消息后，必须强制等待所有 cpu 返回 Invalidate ack 之后，再把写缓冲区中的数据强制刷回高速缓存和主内存中。

有序性（看到的读写顺序乱了）

load 操作时，判断失效队列非空，强制让失效队列中的缓存全部失效，在执行读取操作（高速缓存中没有数据就从主内存中读取）。
## volatile、synchronized 是如何基于内存屏障来保证可见性与有序性的